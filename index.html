<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Geometric Flow Field</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
    
    <style>
        /* CSS Reset for Full Screen Mobile Experience */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents scrollbars */
            background-color: #0d1117; 
            touch-action: none; /* Disables browser zooming/panning gestures */
        }
        main {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block; /* Removes default inline spacing */
        }
    </style>
</head>
<body>

    <main id="sketch-container"></main>

    <script>
        // --- Configuration ---
        const FLOW_FIELD_RESOLUTION = 20; 
        const STEP_SIZE = 15;           
        const LINE_LENGTH = 80;        // Slightly shorter for mobile performance
        const MAX_PARTICLES = 1500;     // Lowered slightly for mobile battery/performance optimization
        let turbulenceScale = 0.02;    

        // --- Global Variables ---
        let particles = [];
        let flowField;
        let p5Instance; 

        class Particle {
            constructor(startX, startY) {
                this.init(startX, startY);
                this.maxPathLength = LINE_LENGTH;
            }

            init(x, y) {
                this.pos = p5Instance.createVector(x, y);
                // Random spread around the touch point
                this.pos.add(p5Instance.random(-10, 10), p5Instance.random(-10, 10));
                this.path = [];
                this.isDead = false;
            }

            update() {
                if (this.isDead) return;

                let x = p5Instance.floor(this.pos.x / FLOW_FIELD_RESOLUTION);
                let y = p5Instance.floor(this.pos.y / FLOW_FIELD_RESOLUTION);
                const cols = p5Instance.floor(p5Instance.width / FLOW_FIELD_RESOLUTION);
                const rows = p5Instance.floor(p5Instance.height / FLOW_FIELD_RESOLUTION);

                if (x < 0 || x >= cols || y < 0 || y >= rows) {
                    this.isDead = true;
                    return;
                }

                let index = x + y * cols;
                let force = flowField[index];
                
                if (!force) {
                    this.isDead = true;
                    return;
                }

                // --- Touch/Mouse Interaction ---
                // Works for both single mouse click and multi-touch on phones
                if (p5Instance.mouseIsPressed || (p5Instance.touches.length > 0)) {
                    // Iterate through all active touches to allow multi-finger drawing
                    let inputPoints = p5Instance.touches.length > 0 ? p5Instance.touches : [{x: p5Instance.mouseX, y: p5Instance.mouseY}];
                    
                    for (let point of inputPoints) {
                        let mx = point.x;
                        let my = point.y;
                        
                        let directionToMouse = p5.Vector.sub(p5Instance.createVector(mx, my), this.pos);
                        let distance = directionToMouse.mag();
                        
                        if (distance < 150) { 
                            directionToMouse.normalize();
                            directionToMouse.mult(p5Instance.map(distance, 0, 150, 0.4, 0)); 
                            force.add(directionToMouse);
                        }
                    }
                }
                
                let steer = force.copy(); 
                steer.normalize();
                this.pos.add(p5.Vector.mult(steer, STEP_SIZE));

                this.path.push(p5Instance.createVector(this.pos.x, this.pos.y));
                if (this.path.length > this.maxPathLength) {
                    this.path.shift();
                }

                if (this.pos.x < 0 || this.pos.x > p5Instance.width || this.pos.y < 0 || this.pos.y > p5Instance.height) {
                    this.isDead = true;
                }
            }

            draw() {
                if (this.isDead || this.path.length < 2) return;

                let weight = 1.5; 
                if (p5Instance.mouseIsPressed || (p5Instance.touches.length > 0)) {
                    weight = 1.0; 
                }
                p5Instance.strokeWeight(weight);
                p5Instance.noFill();

                // Dynamic Hue based on screen width
                let dynamicHue = p5Instance.map(this.pos.x, 0, p5Instance.width, 0, 360);
                let alpha = p5Instance.map(this.path.length, 0, this.maxPathLength, 0, 100);

                p5Instance.stroke(dynamicHue, 90, 100, alpha); 

                p5Instance.beginShape();
                for (let v of this.path) {
                    p5Instance.vertex(v.x, v.y);
                }
                p5Instance.endShape();
            }
        }

        const sketch = (p) => {
            p5Instance = p; 

            p.setup = () => {
                // Create canvas that fills the whole mobile window
                p.createCanvas(p.windowWidth, p.windowHeight);
                p.frameRate(60); // 60 FPS is standard for smooth mobile performance
                p.colorMode(p.HSB, 360, 100, 100, 100);
                p.background(0);
                initializeFlowField();
                particles = [];
            };

            p.draw = () => {
                p.fill(0, 0, 0, 10); 
                p.rect(0, 0, p.width, p.height);
                p.noStroke();

                // Handle spawning for Mouse AND Touch
                if (p.mouseIsPressed) {
                     spawnParticles(p.mouseX, p.mouseY);
                }
                // Handle multi-touch spawning
                if (p.touches.length > 0) {
                    for (let t of p.touches) {
                        spawnParticles(t.x, t.y);
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    let particle = particles[i];
                    particle.update();
                    particle.draw();

                    if (particle.isDead) {
                        particles.splice(i, 1);
                    }
                }
            };

            function spawnParticles(x, y) {
                // Spawn rate
                for(let k = 0; k < 2; k++) { // Spawn 2 particles per frame per touch point
                     if (particles.length < MAX_PARTICLES) {
                         particles.push(new Particle(x, y));
                     }
                }
            }

            p.windowResized = () => {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                p.background(0); 
                initializeFlowField();
                particles = [];
            };

            function initializeFlowField() {
                const cols = p.floor(p.width / FLOW_FIELD_RESOLUTION);
                const rows = p.floor(p.height / FLOW_FIELD_RESOLUTION);
                const numVectors = cols * rows;

                flowField = new Array(numVectors);
                let zoff = p.random(1000); 
                let xoff = zoff;

                for (let x = 0; x < cols; x++) {
                    let yoff = zoff;
                    for (let y = 0; y < rows; y++) {
                        let noiseValue = p.noise(xoff * turbulenceScale, yoff * turbulenceScale);
                        let angle = p.round(noiseValue * 8) * p.PI / 4; 
                        let v = p.createVector(p.cos(angle), p.sin(angle));
                        let index = x + y * cols;
                        flowField[index] = v;
                        yoff += 0.05; 
                    }
                    xoff += 0.05; 
                }
            }
        };

        window.onload = function () {
            new p5(sketch, 'sketch-container');
        };
        
        // Prevent default touch behavior (scrolling) to allow drawing
        document.addEventListener('touchmove', function(e) { e.preventDefault(); }, { passive: false });

    </script>
</body>
</html>
